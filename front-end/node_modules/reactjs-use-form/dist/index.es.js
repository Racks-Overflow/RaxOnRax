import { useState, useEffect, useCallback } from 'react';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

/**
 * Reactive form management and input field validation hook
 *
 * @param {object} formModel - initial form model with optional validation function.
 * @param {function} formSubmitCallback - function to run after form validation and submission.
 * @returns {{handleOnChange: function, handleOnSubmit: function, values: object, errors: object, isDisabled: boolean, isSubmitted: boolean}}
 **/
function useForm(formModel, formSubmitCallback) {
    var _a = useState(initializeState(formModel, 'values')), values = _a[0], setValues = _a[1];
    var _b = useState(initializeState(formModel, 'errors')), errors = _b[0], setErrors = _b[1];
    var _c = useState(initializeState(formModel, '_isDirty')), _isDirty = _c[0], setIsDirty = _c[1];
    var _d = useState(true), isDisabled = _d[0], setIsDisabled = _d[1];
    var _e = useState(false), isSubmitted = _e[0], setIsSubmitted = _e[1];
    var _f = useState(false), _isTouched = _f[0], setIsTouched = _f[1];
    useEffect(function () {
        /*
         validate all dirty input field via the validator
         function when the values state changes
        */
        if (_isTouched) {
            var isDirtyInputs = Object.keys(_isDirty).reduce(function (inputs, inputName) {
                if (_isDirty[inputName])
                    inputs[inputName] = _isDirty[inputName];
                return inputs;
            }, {});
            Object.keys(isDirtyInputs).forEach(function (inputName) {
                var error;
                var requiredMessage = { hasError: true, message: 'This field is required' };
                var clearMessage = { hasError: false, message: '' };
                var _isDirtyInput = formModel[inputName];
                var inputValue = values[inputName];
                error = _isDirtyInput.required && !inputValue ? requiredMessage : clearMessage;
                if (_isDirtyInput['validator']) {
                    // proceed only if the input field has a validator function
                    var _validatorFunc = _isDirtyInput['validator'];
                    var validatorMessage = {
                        hasError: true,
                        message: _validatorFunc(inputValue, values),
                    };
                    var errorMessage = inputValue ? validatorMessage : requiredMessage;
                    error = _validatorFunc(inputValue, values) ? errorMessage : clearMessage;
                }
                if (errors[inputName].message !== error.message) {
                    // proceed only after comparing previous error message value and current value
                    setErrors(function (errors) {
                        var _a;
                        return (__assign(__assign({}, errors), (_a = {}, _a[inputName] = error, _a)));
                    });
                }
            });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [values]);
    var isFormInvalid = useCallback(function () {
        /*
         the form will be invalid if one of its fields
         has some errors or a required input field is empty
        */
        var _isRequired = initializeState(formModel, '_isRequired');
        // {_isRequired} is read-only and doesn't require a useState
        var isRequiredInputs = Object.keys(_isRequired).reduce(function (inputs, inputName) {
            if (_isRequired[inputName])
                inputs[inputName] = _isRequired[inputName];
            return inputs;
        }, {});
        var formHasErrors = function () { return Object.values(errors).some(function (error) { return error.hasError; }); };
        var isRequiredInputEmpty = function () { return Object.keys(isRequiredInputs).some(function (key) { return !values[key]; }); };
        return formHasErrors() || isRequiredInputEmpty();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [errors]);
    useEffect(function () {
        /*
         this will be fired after every change in the errors
         state to be able to enable/disable the submit button
        */
        if (_isTouched) {
            setIsDisabled(isFormInvalid());
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [errors]);
    var handleOnChange = useCallback(function (event) {
        setIsTouched(true);
        var inputName = event.currentTarget.name;
        var inputValue = event.currentTarget.value;
        if (formModel[inputName]) {
            // proceed only if the change input exits in the formModel
            setValues(function (values) {
                var _a;
                return (__assign(__assign({}, values), (_a = {}, _a[inputName] = inputValue, _a)));
            });
            if (_isDirty[inputName] === false) {
                // proceed only if input field is not dirty
                setIsDirty(function (_isDirty) {
                    var _a;
                    return (__assign(__assign({}, _isDirty), (_a = {}, _a[inputName] = true, _a)));
                });
            }
        }
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [values]);
    var handleOnSubmit = useCallback(function (event) {
        event.preventDefault();
        if (!isFormInvalid()) {
            formSubmitCallback();
            setIsSubmitted(true);
        }
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [isFormInvalid, values]);
    return {
        handleOnChange: handleOnChange,
        handleOnSubmit: handleOnSubmit,
        values: values,
        errors: errors,
        isSubmitted: isSubmitted,
        isDisabled: isDisabled,
    };
}
function initializeState(formModel, state) {
    /*
     initialize an empty state for {errors} and {_isDirty} where
     {values} and {_isRequired} are pulled from the formModel
    */
    switch (state) {
        case 'values':
            return Object.keys(formModel).reduce(function (inputValues, inputName) {
                inputValues[inputName] = formModel[inputName]['value'];
                return inputValues;
            }, {});
        case 'errors':
            return Object.keys(formModel).reduce(function (inputErrors, inputName) {
                inputErrors[inputName] = { hasError: false, message: '' };
                return inputErrors;
            }, {});
        case '_isDirty':
            return Object.keys(formModel).reduce(function (dirtyInputs, inputName) {
                dirtyInputs[inputName] = false;
                return dirtyInputs;
            }, {});
        case '_isRequired':
            return Object.keys(formModel).reduce(function (requiredInputs, inputName) {
                requiredInputs[inputName] = formModel[inputName]['required'];
                return requiredInputs;
            }, {});
        default:
            return {};
    }
}

export { useForm };
